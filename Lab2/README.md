# Лабораторная работа №2
Чан Тхи Лиен К3240
# Ход работы
## 1. Плохой Dockerfile (bad.Dockerfile)
```bash
# Используем большой базовый образ
FROM ubuntu:latest

# Устанавливаем пакеты и обновляем систему в одной строке без очистки кеша
RUN apt-get update
RUN apt-get install -y python3 python3-pip

# Копируем всё содержимое директории, включая ненужные файлы
COPY . /app

# Устанавливаем зависимости напрямую от root
RUN pip3 install -r /app/requirements.txt

# Запускаем контейнер от root
WORKDIR /app

EXPOSE 5000

CMD ["python3", "app.py"]
```
## 2. Хороший Dockerfile (good.Dockerfile)
```bash
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

COPY . .

ENV FLASK_ENV=production
EXPOSE 5000

CMD ["python", "app.py"]
```
## 3. Файл app.py
```bash
from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello():
    return "Hello from Docker container!"

if __name__ == '__main__':
    # Для демонстрации запускаем на всех интерфейсах
    app.run(host='0.0.0.0', port=5000)
```
## 4. Файл requirements.txt
```bash
flask==3.0.3
```
## 5. Плохие практики в bad.Dockerfile
### Использование `ubuntu:latest` как базового образа
- `ubuntu:latest` — большой образ, который содержит много ненужных пакетов. Это увеличивает размер контейнера и время сборки.
- Исправлено: Использован минималистичный образ `python:3.10-slim`.
- Размер образа стал меньше, сборка — быстрее, меньше уязвимостей.
### Много отдельных RUN инструкций
- После установки пакетов остаются временные файлы и кеш, что увеличивает размер образа.
- Исправлено: После установки — `apt-get clean && rm -rf /var/lib/apt/lists/* и pip install --no-cache-dir`.
- Образ стал легче на сотни мегабайт.
### COPY . /app копирует всё подряд
- Каждый RUN создаёт новый слой → увеличивает размер образа и усложняет кэширование
- Объединили команды (`RUN pip install … && apt-get clean`) и используем флаг `--no-cache-dir`
- Быстрее сборка, меньше размер, меньше мусора в образе.
## 6. Плохие практики при работе с контейнерами
### Хранить данные внутри контейнера
- При удалении контейнера все данные исчезнут, нельзя будет восстановить.
- Исправлено: Использовать volumes для хранения данных (`docker volume create`, `-v /data:/app/data`).
### Запуск множества процессов в одном контейнере
- Контейнер должен выполнять одну задачу. Несколько процессов усложняют перезапуск и масштабирование.
- Исправлено: Разделять сервисы по контейнерам: база данных, API, фронтенд — каждый в своём.
## 7. Запуск проекта
```bash
docker build -f bad.Dockerfile -t bad-app .
docker run -p 5000:5000 bad-app
```
```bash
docker build -f good.Dockerfile -t good-app .
docker run -p 5000:5000 good-app
```
# Вывод
- В этой лабораторной работе показано, как выбор базового образа, порядок инструкций и настройка окружения
влияет на размер, безопасность и удобство использования контейнера.
- В результате работы были получены практические навыки по оптимизации Dockerfile и осознание важности
соблюдения принципов минимализма, безопасности и воспроизводимости при создании контейнеров.
